'use server'

import { createConnection } from '@/lib/db';

export type InternshipResult = {
  internshipID: number;
  title: string;
  companyName: string; // From the JOIN
  location: string;
  description: string;
  status: string;
  postDate: string;
};

export async function searchInternships(formData: FormData) {
  // 1. Extract values from the form
  const keyword = formData.get('keyword') as string;
  const location = formData.get('location') as string;

  let connection;
  try {
    connection = await createConnection();

    // 2. Build the Complex Query
    // We JOIN 'Internship' with 'Company' so we can search by Company Name too
    let sql = `
      SELECT 
        i.internshipID, 
        i.title, 
        c.companyName, 
        i.location, 
        i.description, 
        i.status, 
        i.postDate 
      FROM Internship i
      JOIN Company c ON i.companyID = c.companyID
      WHERE i.status = 'open'
    `;

    const params: (string | number)[] = [];

    // 3. Add Dynamic Filters
    if (keyword) {
      sql += ` AND (i.title LIKE ? OR c.companyName LIKE ?)`;
      params.push(`%${keyword}%`, `%${keyword}%`);
    }

    if (location) {
      sql += ` AND i.location LIKE ?`;
      params.push(`%${location}%`);
    }

    sql += ` ORDER BY i.postDate DESC LIMIT 20`;

    // 4. Execute
    const [rows] = await connection.execute(sql, params);
    return rows as InternshipResult[];

  } catch (error) {
    console.error('Search Error:', error);
    return [];
  } finally {
    if (connection) await connection.end();
  }
}

// --- FEATURE 2: REGISTER APPLICANT ---
export async function registerApplicant(formData: FormData) {
  const firstName = formData.get('firstName') as string;
  const lastName = formData.get('lastName') as string;
  const email = formData.get('email') as string;
  const password = formData.get('password') as string;
  const telNo = formData.get('telNo') as string;
  
  // Applicant specific fields
  const fieldOfStudy = formData.get('fieldOfStudy') as string;
  const gpa = formData.get('gpa') as string;
  const gradYear = formData.get('gradYear') as string;
  const age = formData.get('age') as string;
  const resumeUrl = formData.get('resumeUrl') as string;

  let connection;
  try {
    connection = await createConnection();

    // 1. Start Transaction (Ensures both inserts happen, or neither does)
    await connection.beginTransaction();

    // 2. Insert into Parent Table (User)
    const [userResult]: any = await connection.execute(
      `INSERT INTO User (userRole, fName, lName, password, telNo, email) 
       VALUES ('applicant', ?, ?, ?, ?, ?)`,
      [firstName, lastName, password, telNo, email]
    );

    // Capture the ID generated by MySQL
    const newUserId = userResult.insertId;

    // 3. Insert into Child Table (Applicant)
    // We use 'active' as the default status
    await connection.execute(
      `INSERT INTO Applicant (applicantID, fieldOfStudy, gpa, resumeURL, expectedGraduationYear, status, age)
       VALUES (?, ?, ?, ?, ?, 'active', ?)`,
      [newUserId, fieldOfStudy, parseFloat(gpa) || 0, resumeUrl, parseInt(gradYear) || 2026, parseInt(age) || 20]
    );

    // 4. Commit the changes
    await connection.commit();
    
    return { success: true, message: `Welcome, ${firstName}! Your User ID is ${newUserId}` };

  } catch (error: any) {
    if (connection) await connection.rollback(); // Undo if error
    console.error('Registration Error:', error);
    return { success: false, message: 'Registration failed. Email might already exist.' };
  } finally {
    if (connection) await connection.end();
  }
}

// --- FEATURE 3: POST INTERNSHIP (RECRUITER) ---
export async function postInternship(formData: FormData) {
  // Extract data from the form
  const title = formData.get('title') as string;
  const location = formData.get('location') as string;
  const salary = formData.get('salary') as string;
  const description = formData.get('description') as string;
  const requirements = formData.get('requirements') as string;
  
  // Hardcoded for demo (Assumes Company ID 1 exists)
  const companyID = 1; 

  let connection;
  try {
    connection = await createConnection();

    // We insert with 'open' status and current date for postDate
    await connection.execute(
      `INSERT INTO Internship 
       (companyID, title, description, location, salary, startDate, endDate, requirements, status, postDate)
       VALUES (?, ?, ?, ?, ?, CURDATE(), CURDATE() + INTERVAL 4 MONTH, ?, 'open', CURDATE())`,
      [companyID, title, description, location, parseFloat(salary) || 0, requirements]
    );

    return { success: true, message: 'Internship posted successfully! Go to Search to see it.' };

  } catch (error: any) {
    console.error('Posting Error:', error);
    return { success: false, message: 'Failed to post job.' };
  } finally {
    if (connection) await connection.end();
  }
}

// --- FEATURE 4: SUBMIT APPLICATION ---
export async function submitApplication(formData: FormData) {
  const applicantID = formData.get('applicantID') as string;
  const internshipID = formData.get('internshipID') as string;

  let connection;
  try {
    connection = await createConnection();
    await connection.beginTransaction();

    // 1. Check if already applied (Optional but good practice)
    const [existing]: any = await connection.execute(
      'SELECT applicationID FROM Application WHERE applicantID = ? AND internshipID = ?',
      [applicantID, internshipID]
    );

    if (existing.length > 0) {
      await connection.rollback();
      return { success: false, message: 'You have already applied to this job!' };
    }

    // 2. Create the Application Record
    const [appResult]: any = await connection.execute(
      `INSERT INTO Application (applicantID, internshipID, applicationDeadline, submissionDate)
       VALUES (?, ?, CURDATE() + INTERVAL 30 DAY, CURDATE())`,
      [applicantID, internshipID]
    );
    
    const newAppID = appResult.insertId;

    // 3. Create the Initial Status History (Submitted)
    await connection.execute(
      `INSERT INTO ApplicationStatusHistory (applicationID, statusName, dateChanged, notes, outcome)
       VALUES (?, 'Submitted', CURDATE(), 'Application received via Web Portal', 'pending')`,
      [newAppID]
    );

    await connection.commit();
    return { success: true, message: 'Application submitted successfully!' };

  } catch (error: any) {
    if (connection) await connection.rollback();
    console.error('Application Error:', error);
    return { success: false, message: 'Failed to apply. Check ID.' };
  } finally {
    if (connection) await connection.end();
  }
}

// --- FEATURE 5: MY APPLICATIONS & ANALYTICS ---

export async function getApplicationHistory(applicantID: number) {
  let connection;
  try {
    connection = await createConnection();

    // COMPLEX QUERY: Joins 4 tables to get the full story of an application
    const [rows] = await connection.execute(
      `SELECT 
          a.applicationID,
          i.title,
          c.companyName,
          a.submissionDate,
          ash.statusName,
          ash.outcome,
          ash.notes
       FROM Application a
       JOIN Internship i ON a.internshipID = i.internshipID
       JOIN Company c ON i.companyID = c.companyID
       -- We LEFT JOIN to get history if it exists
       LEFT JOIN ApplicationStatusHistory ash ON a.applicationID = ash.applicationID
       WHERE a.applicantID = ?
       ORDER BY a.submissionDate DESC, ash.dateChanged DESC`,
      [applicantID]
    );
    return rows as any[];

  } catch (error) {
    console.error('History Error:', error);
    return [];
  } finally {
    if (connection) await connection.end();
  }
}

export async function getAnalytics(applicantID: number) {
  let connection;
  try {
    connection = await createConnection();

    // COMPLEX QUERY: Aggregation to count applications by outcome
    const [stats]: any = await connection.execute(
      `SELECT 
          COUNT(*) as total,
          SUM(CASE WHEN ash.outcome = 'accepted' THEN 1 ELSE 0 END) as accepted,
          SUM(CASE WHEN ash.outcome = 'rejected' THEN 1 ELSE 0 END) as rejected,
          SUM(CASE WHEN ash.outcome = 'pending' THEN 1 ELSE 0 END) as pending
       FROM Application a
       LEFT JOIN ApplicationStatusHistory ash ON a.applicationID = ash.applicationID
       WHERE a.applicantID = ?`,
      [applicantID]
    );

    return stats[0];

  } catch (error) {
    console.error('Analytics Error:', error);
    return { total: 0, accepted: 0, rejected: 0, pending: 0 };
  } finally {
    if (connection) await connection.end();
  }
}